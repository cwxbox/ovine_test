"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
exports.fetchFile = exports.getPkgLatestVer = exports.getPkgName = exports.getDllManifestFile = exports.getDllHostDir = exports.getModulePath = exports.getCliDevRootDir = exports.isCliDev = exports.globalStore = exports.mergeWebpackConfig = exports.compileWebpack = exports.normalizeUrl = void 0;
var child_process_1 = require("child_process");
var fs_extra_1 = __importDefault(require("fs-extra"));
var http_1 = __importDefault(require("http"));
var https_1 = __importDefault(require("https"));
var import_fresh_1 = __importDefault(require("import-fresh"));
var lodash_1 = __importDefault(require("lodash"));
var path_1 = __importDefault(require("path"));
var webpack_1 = __importDefault(require("webpack"));
var webpack_merge_1 = __importDefault(require("webpack-merge"));
var constants_1 = require("./constants");
function normalizeUrl(rawUrls) {
    var urls = rawUrls;
    var resultArray = [];
    // If the first part is a plain protocol, we combine it with the next part.
    if (urls[0].match(/^[^/:]+:\/*$/) && urls.length > 1) {
        var first = urls.shift();
        urls[0] = first + urls[0];
    }
    // There must be two or three slashes in the file protocol,
    // two slashes in anything else.
    var replacement = urls[0].match(/^file:\/\/\//) ? '$1:///' : '$1://';
    urls[0] = urls[0].replace(/^([^/:]+):\/*/, replacement);
    // eslint-disable-next-line
    for (var i = 0; i < urls.length; i++) {
        var component = urls[i];
        if (typeof component !== 'string') {
            throw new TypeError("Url must be a string. Received " + typeof component);
        }
        if (component === '') {
            // eslint-disable-next-line
            continue;
        }
        if (i > 0) {
            // Removing the starting slashes for each component but the first.
            component = component.replace(/^[/]+/, '');
        }
        // Removing the ending slashes for each component but the last.
        // For the last component we will combine multiple slashes to a single one.
        component = component.replace(/[/]+$/, i < urls.length - 1 ? '' : '/');
        resultArray.push(component);
    }
    var str = resultArray.join('/');
    // Each input component is now separated by a single slash
    // except the possible first plain protocol part.
    // Remove trailing slash before parameters or hash.
    str = str.replace(/\/(\?|&|#[^!])/g, '$1');
    // Replace ? in parameters with &.
    var parts = str.split('?');
    str = parts.shift() + (parts.length > 0 ? '?' : '') + parts.join('&');
    // Dedupe forward slashes.
    str = str.replace(/^\/+/, '/');
    return str;
}
exports.normalizeUrl = normalizeUrl;
function compileWebpack(config) {
    return new Promise(function (resolve, reject) {
        var compiler = webpack_1["default"](config);
        compiler.run(function (err, stats) {
            if (err) {
                reject(err);
            }
            if (stats === null || stats === void 0 ? void 0 : stats.hasErrors()) {
                stats.toJson('errors-only').errors.forEach(function (e) {
                    console.error(e);
                });
                reject(new Error('Failed to compile with errors.'));
            }
            if (stats === null || stats === void 0 ? void 0 : stats.hasWarnings()) {
                stats.toJson('errors-warnings').warnings.forEach(function (warning) {
                    console.warn(warning);
                });
            }
            resolve(true);
        });
    });
}
exports.compileWebpack = compileWebpack;
function mergeWebpackConfig(baseConfig, config) {
    var webpackConfig = baseConfig;
    if (typeof config === 'object') {
        webpackConfig = webpack_merge_1["default"](baseConfig, config);
    }
    else if (typeof config === 'string' && fs_extra_1["default"].existsSync(config)) {
        webpackConfig = webpack_merge_1["default"](baseConfig, import_fresh_1["default"](config));
    }
    return webpackConfig;
}
exports.mergeWebpackConfig = mergeWebpackConfig;
var store = {};
function globalStore(type, key, value) {
    if (type === 'set') {
        lodash_1["default"].set(store, key, value);
        return undefined;
    }
    return lodash_1["default"].get(store, key, value);
}
exports.globalStore = globalStore;
function isCliDev() {
    return __dirname.indexOf("@" + constants_1.libName) === -1 && __dirname.indexOf(constants_1.libRootPath + "/") > -1;
}
exports.isCliDev = isCliDev;
function getCliDevRootDir() {
    return __dirname.substring(0, __dirname.indexOf(constants_1.libRootPath)) + constants_1.libRootPath;
}
exports.getCliDevRootDir = getCliDevRootDir;
function getModulePath(siteDir, lib, required) {
    if (required === void 0) { required = false; }
    var isDev = isCliDev();
    var devRootDir = getCliDevRootDir();
    var isLib = lib.indexOf('lib/') === 0;
    var libPath = !isLib ? lib : lib.replace(/^lib\//, '');
    var prodPath = "node_modules/" + (!isLib ? '' : "@" + constants_1.libName + "/") + libPath;
    var libPaths = [
        siteDir + "/" + prodPath,
        path_1["default"].resolve(siteDir, "../../" + prodPath),
        path_1["default"].resolve(siteDir, "../../../../" + prodPath),
    ];
    if (isDev) {
        libPaths.push(devRootDir + "/" + prodPath);
    }
    if (isDev && isLib) {
        libPaths.push(devRootDir + "/packages/" + libPath);
    }
    var modulePath = libPaths.find(function (corePath) { return fs_extra_1["default"].pathExistsSync(corePath); });
    if (!modulePath && required) {
        throw new Error("Can not find path: " + lib + ".\nSearched paths:\n" + libPaths.join('\n'));
    }
    return modulePath;
}
exports.getModulePath = getModulePath;
function getDllHostDir(options) {
    var publicPath = options.publicPath, _a = options.dll, dll = _a === void 0 ? {} : _a;
    var confHostDir = dll.hostDir || "" + (dll.publicPath || publicPath) + constants_1.dllVendorDirPath + "/";
    var hostDir = (dll.useJsdelivr ? constants_1.dllJsdelivrHostDir : confHostDir)
        .replace('[libVer]', constants_1.libVer)
        .replace('[dllVer]', constants_1.dllVer);
    var backHostDir = "" + publicPath + constants_1.dllVendorDirPath + "/";
    return [hostDir, backHostDir];
}
exports.getDllHostDir = getDllHostDir;
function getDllManifestFile(siteDir) {
    var assetsFile = siteDir + "/" + constants_1.dllAssetsFile.replace('[name]', constants_1.dllVendorFileName);
    var manifestFile = siteDir + "/" + constants_1.dllManifestFile.replace('[name]', constants_1.dllVendorFileName);
    return {
        assetsFile: assetsFile,
        manifestFile: manifestFile
    };
}
exports.getDllManifestFile = getDllManifestFile;
function getPkgName(pkg) {
    return "@" + constants_1.libName + "/" + (pkg || '');
}
exports.getPkgName = getPkgName;
function getPkgLatestVer() {
    var latestVer = constants_1.libVer;
    try {
        latestVer = child_process_1.execSync("npm view " + getPkgName('cli') + " version")
            .toString()
            .replace('\n', '');
    }
    catch (err) {
        //
    }
    return latestVer;
}
exports.getPkgLatestVer = getPkgLatestVer;
function fetchFile(url) {
    return __awaiter(this, void 0, void 0, function () {
        var proto;
        return __generator(this, function (_a) {
            proto = url.startsWith('https') ? https_1["default"] : http_1["default"];
            return [2 /*return*/, new Promise(function (resolve, reject) {
                    var onError = function (tip) {
                        if (tip === void 0) { tip = ''; }
                        reject(new Error("Failed to get '" + url + "'. " + tip));
                    };
                    var request = proto.get(url, function (response) {
                        if (response.statusCode !== 200) {
                            onError("StatusCode: " + response.statusCode);
                            return;
                        }
                        var body = '';
                        response.on('data', function (chunk) {
                            body += chunk;
                        });
                        response.on('error', function () {
                            onError('Response an error occurred.');
                        });
                        response.on('end', function () {
                            resolve(__assign(__assign({}, response), { body: body }));
                        });
                    });
                    request.on('error', function () {
                        onError('Request an error occurred.');
                    });
                })];
        });
    });
}
exports.fetchFile = fetchFile;
