"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var fs = __importStar(require("fs"));
var loaderUtils = __importStar(require("loader-utils"));
var features_1 = require("monaco-editor-webpack-plugin/out/features");
var languages_1 = require("monaco-editor-webpack-plugin/out/languages");
var AddWorkerEntryPointPlugin_1 = require("monaco-editor-webpack-plugin/out/plugins/AddWorkerEntryPointPlugin");
var path = __importStar(require("path"));
var webpack = __importStar(require("webpack"));
var constants_1 = require("../../constants");
var INCLUDE_LOADER_PATH = require.resolve('monaco-editor-webpack-plugin/out/loaders/include');
var EDITOR_MODULE = {
    label: 'editorWorkerService',
    entry: undefined,
    worker: {
        id: 'vs/editor/editor',
        entry: 'vs/editor/editor.worker'
    }
};
var languagesById = {};
languages_1.languagesArr.forEach(function (language) {
    languagesById[language.label] = language;
});
var featuresById = {};
features_1.featuresArr.forEach(function (feature) {
    featuresById[feature.label] = feature;
});
/**
 * Return a resolved path for a given Monaco file.
 */
function resolveMonacoPath(filePath) {
    try {
        return require.resolve(path.join('monaco-editor/esm', filePath));
    }
    catch (err) {
        try {
            return require.resolve(path.join(process.cwd(), 'node_modules/monaco-editor/esm', filePath));
        }
        catch (error) {
            return require.resolve(filePath);
        }
    }
}
/**
 * Return the interpolated final filename for a worker, respecting the file name template.
 */
function getWorkerFilename(filename, entry) {
    return loaderUtils.interpolateName({ resourcePath: entry }, filename, {
        content: fs.readFileSync(resolveMonacoPath(entry))
    });
}
function getFeaturesIds(userFeatures) {
    function notContainedIn(arr) {
        return function (element) { return arr.indexOf(element) === -1; };
    }
    var featuresIds;
    if (userFeatures.length) {
        var excludedFeatures = userFeatures.filter(function (f) { return f[0] === '!'; }).map(function (f) { return f.slice(1); });
        if (excludedFeatures.length) {
            featuresIds = Object.keys(featuresById).filter(notContainedIn(excludedFeatures));
        }
        else {
            featuresIds = userFeatures;
        }
    }
    else {
        featuresIds = Object.keys(featuresById);
    }
    return featuresIds;
}
var MonacoEditorWebpackPlugin = /** @class */ (function () {
    function MonacoEditorWebpackPlugin(options) {
        if (options === void 0) { options = {}; }
        var languages = options.languages || Object.keys(languagesById);
        var customLanguages = options.customLanguages || [];
        var features = getFeaturesIds(options.features || []);
        this.options = {
            languages: coalesce(languages.map(function (id) { return languagesById[id]; })).concat(customLanguages),
            features: coalesce(features.map(function (id) { return featuresById[id]; })),
            filename: options.filename || '[name].worker.js',
            publicPath: options.publicPath || ''
        };
    }
    MonacoEditorWebpackPlugin.prototype.apply = function (compiler) {
        var _a = this.options, languages = _a.languages, features = _a.features, filename = _a.filename, publicPath = _a.publicPath;
        // const compilationPublicPath = getCompilationPublicPath(compiler)
        var modules = [EDITOR_MODULE].concat(languages).concat(features);
        var workers = [];
        modules.forEach(function (module) {
            if (module.worker) {
                workers.push({
                    label: module.label,
                    id: module.worker.id,
                    entry: module.worker.entry
                });
            }
        });
        var rules = createLoaderRules(languages, features, workers, filename, publicPath
        // compilationPublicPath
        );
        var plugins = createPlugins(workers, filename);
        addCompilerRules(compiler, rules);
        addCompilerPlugins(compiler, plugins);
    };
    return MonacoEditorWebpackPlugin;
}());
function addCompilerRules(compiler, rules) {
    var compilerOptions = compiler.options;
    if (!compilerOptions.module) {
        compilerOptions.module = { rules: rules };
    }
    else {
        var moduleOptions = compilerOptions.module;
        moduleOptions.rules = (moduleOptions.rules || []).concat(rules);
    }
}
function addCompilerPlugins(compiler, plugins) {
    plugins.forEach(function (plugin) { return plugin.apply(compiler); });
}
// function getCompilationPublicPath(compiler: webpack.Compiler): string {
//   if (compiler.options.output && compiler.options.output.publicPath) {
//     if (typeof compiler.options.output.publicPath === 'string') {
//       return compiler.options.output.publicPath
//     } else {
//       console.warn(`Cannot handle options.publicPath (expected a string)`)
//     }
//   }
//   return ''
// }
function createLoaderRules(languages, features, workers, filename, pluginPublicPath
// compilationPublicPath: string
) {
    if (!languages.length && !features.length) {
        return [];
    }
    var languagePaths = flatArr(coalesce(languages.map(function (language) { return language.entry; })));
    var featurePaths = flatArr(coalesce(features.map(function (feature) { return feature.entry; })));
    var workerPaths = fromPairs(workers.map(function (_a) {
        var label = _a.label, entry = _a.entry;
        return [label, getWorkerFilename(filename, entry)];
    }));
    if (workerPaths.typescript) {
        // javascript shares the same worker
        workerPaths.javascript = workerPaths.typescript;
    }
    if (workerPaths.css) {
        // scss and less share the same worker
        workerPaths.less = workerPaths.css;
        workerPaths.scss = workerPaths.css;
    }
    if (workerPaths.html) {
        // handlebars, razor and html share the same worker
        workerPaths.handlebars = workerPaths.html;
        workerPaths.razor = workerPaths.html;
    }
    // Determine the public path from which to load worker JS files. In order of precedence:
    // 1. Plugin-specific public path.
    // 2. Dynamic runtime public path.
    // 3. Compilation public path.
    // const pathPrefix = Boolean(pluginPublicPath)
    //   ? JSON.stringify(pluginPublicPath)
    //   : `typeof __webpack_public_path__ === 'string' ` +
    //     `? __webpack_public_path__ ` +
    //     `: ${JSON.stringify(compilationPublicPath)}`
    // Fix dll path
    var pathPrefix = "window." + constants_1.winConst.dllPath + " || " + JSON.stringify(pluginPublicPath);
    var globals = {
        MonacoEnvironment: "(function (paths) {\n      function stripTrailingSlash(str) {\n        return str.replace(/\\/$/, '');\n      }\n      return {\n        getWorkerUrl: function (moduleId, label) {\n          var pathPrefix = " + pathPrefix + ";\n          var result = (pathPrefix ? stripTrailingSlash(pathPrefix) + '/' : '') + paths[label];\n          if (/^((http:)|(https:)|(file:)|(\\/\\/))/.test(result)) {\n            var currentUrl = String(window.location);\n            var currentOrigin = currentUrl.substr(0, currentUrl.length - window.location.hash.length - window.location.search.length - window.location.pathname.length);\n            if (result.substring(0, currentOrigin.length) !== currentOrigin) {\n              var js = '/*' + label + '*/importScripts(\"' + result + '\");';\n              var blob = new Blob([js], { type: 'application/javascript' });\n              return URL.createObjectURL(blob);\n            }\n          }\n          return result;\n        }\n      };\n    })(" + JSON.stringify(workerPaths, null, 2) + ")"
    };
    return [
        {
            test: /monaco-editor[/\\]esm[/\\]vs[/\\]editor[/\\]editor.(api|main).js/,
            use: [
                {
                    loader: INCLUDE_LOADER_PATH,
                    options: {
                        globals: globals,
                        pre: featurePaths.map(function (importPath) { return resolveMonacoPath(importPath); }),
                        post: languagePaths.map(function (importPath) { return resolveMonacoPath(importPath); })
                    }
                },
            ]
        },
    ];
}
function createPlugins(workers, filename) {
    return [].concat(workers.map(function (_a) {
        var id = _a.id, entry = _a.entry;
        return new AddWorkerEntryPointPlugin_1.AddWorkerEntryPointPlugin({
            id: id,
            entry: resolveMonacoPath(entry),
            filename: getWorkerFilename(filename, entry),
            plugins: [new webpack.optimize.LimitChunkCountPlugin({ maxChunks: 1 })]
        });
    }));
}
function flatArr(items) {
    return items.reduce(function (acc, item) {
        if (Array.isArray(item)) {
            return [].concat(acc).concat(item);
        }
        return [].concat(acc).concat([item]);
    }, []);
}
function fromPairs(values) {
    return values.reduce(function (acc, _a) {
        var _b;
        var key = _a[0], value = _a[1];
        return Object.assign(acc, (_b = {}, _b[key] = value, _b));
    }, {});
}
function coalesce(array) {
    return array.filter(Boolean);
}
module.exports = MonacoEditorWebpackPlugin;
