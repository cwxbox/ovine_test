"use strict";
/**
 * ovine cli main webpack config file.
 */
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
exports.loadDllManifest = exports.createBaseConfig = void 0;
var assets_webpack_plugin_1 = __importDefault(require("assets-webpack-plugin"));
var package_json_1 = require("cache-loader/package.json");
var chalk_1 = __importDefault(require("chalk"));
var clean_webpack_plugin_1 = __importDefault(require("clean-webpack-plugin"));
var copy_webpack_plugin_1 = __importDefault(require("copy-webpack-plugin"));
var fork_ts_checker_webpack_plugin_1 = __importDefault(require("fork-ts-checker-webpack-plugin"));
var fs_extra_1 = __importDefault(require("fs-extra"));
var html_webpack_plugin_1 = __importDefault(require("html-webpack-plugin"));
var lodash_1 = __importStar(require("lodash"));
var mini_css_extract_plugin_1 = __importDefault(require("mini-css-extract-plugin"));
var path_1 = __importDefault(require("path"));
var webpack_1 = require("webpack");
var constants = __importStar(require("../constants"));
var utils_1 = require("../utils");
var amis = __importStar(require("./amis"));
var babel_1 = require("./babel");
var html_hooks_plugin_1 = __importDefault(require("./plugins/html_hooks_plugin"));
var log_plugin_1 = __importDefault(require("./plugins/log_plugin"));
var monaco_editor_plugin_1 = __importDefault(require("./plugins/monaco_editor_plugin"));
var libVer = constants.libVer, libName = constants.libName, generatedDirName = constants.generatedDirName, staticDirName = constants.staticDirName, tsConfFileName = constants.tsConfFileName, tsLintConfFileName = constants.tsLintConfFileName, webpackConfFileName = constants.webpackConfFileName, dllVendorFileName = constants.dllVendorFileName, staticLibDirPath = constants.staticLibDirPath, esLintFileName = constants.esLintFileName, cssAssetsFile = constants.cssAssetsFile, dllFileKeys = constants.dllFileKeys, srcDirName = constants.srcDirName, stylesDirName = constants.stylesDirName, winConst = constants.winConst, dllVer = constants.dllVer;
function createBaseConfig(options) {
    var _a, _b, _c;
    return __awaiter(this, void 0, void 0, function () {
        var outDir, srcDir, genDir, siteDir, publicPath, env, bundleAnalyzer, mock, siteConfig, _d, dll, _e, scssUpdate, envModes, ui, styledConfig, _f, assetJson, manifestFile, dllFilesHostDir, isProd, cacheLoader, babelLoader, useTs, baseConfig, config;
        return __generator(this, function (_g) {
            switch (_g.label) {
                case 0:
                    outDir = options.outDir, srcDir = options.srcDir, genDir = options.genDir, siteDir = options.siteDir, publicPath = options.publicPath, env = options.env, bundleAnalyzer = options.bundleAnalyzer, mock = options.mock, siteConfig = options.siteConfig, _d = options.dll, dll = _d === void 0 ? true : _d, _e = options.scssUpdate, scssUpdate = _e === void 0 ? false : _e;
                    envModes = siteConfig.envModes, ui = siteConfig.ui, styledConfig = siteConfig.styledConfig;
                    return [4 /*yield*/, loadDllManifest(options)
                        // "envModes" must contains "env"
                    ];
                case 1:
                    _f = _g.sent(), assetJson = _f.assetJson, manifestFile = _f.manifestFile, dllFilesHostDir = _f.hostDir;
                    // "envModes" must contains "env"
                    if (envModes && env && !envModes.includes(env)) {
                        throw new Error("env: \"" + env + "\" is not allowed. The \"env\" must be one of \"envModes\": " + envModes + ".");
                    }
                    isProd = utils_1.globalStore('get', 'isProd') || false;
                    cacheLoader = {
                        loader: 'cache-loader',
                        options: {
                            cacheIdentifier: "cache-loader:" + package_json_1.version
                        }
                    };
                    babelLoader = {
                        loader: 'babel-loader',
                        options: babel_1.getBabelConfig({ siteDir: siteDir, styledConfig: styledConfig })
                    };
                    useTs = fs_extra_1["default"].existsSync(siteDir + "/" + tsConfFileName);
                    baseConfig = {
                        mode: process.env.NODE_ENV,
                        entry: getAppEntries({ siteDir: siteDir, hot: options.hot }),
                        output: {
                            // Use future version of asset emitting logic, which allows freeing memory of assets after emitting.
                            publicPath: publicPath,
                            futureEmitAssets: true,
                            pathinfo: false,
                            path: outDir,
                            filename: isProd ? '[name]_[contenthash:6].js' : '[name].js',
                            chunkFilename: isProd ? 'chunks/[name]_[contenthash:6].js' : 'chunks/[name].js'
                        },
                        // throw warning when asset created is over 2.5 M
                        performance: {
                            // TODO: add to config
                            maxEntrypointSize: 2500 * 1024,
                            maxAssetSize: 2000 * 1024,
                            assetFilter: function (filePath) {
                                // Filter genDir or theme files
                                var isLibFiles = /static[\\/]ovine/.test(filePath);
                                var isThemeStyles = /themes[\\/].*\.css/.test(filePath);
                                return !isLibFiles && !isThemeStyles;
                            }
                        },
                        // Omit not necessary stats log
                        stats: {
                            chunkModules: false,
                            assets: false
                        },
                        // Source map help for trick bugs
                        devtool: bundleAnalyzer
                            ? false
                            : isProd
                                ? 'nosources-source-map'
                                : 'cheap-module-eval-source-map',
                        resolve: {
                            extensions: ['.js', '.jsx', '.ts', '.tsx'],
                            symlinks: true,
                            alias: {
                                '~': srcDir,
                                '@generated': genDir,
                                '@core': '@ovine/core/lib',
                                'react-dom': '@hot-loader/react-dom'
                            },
                            // This allows you to set a fallback for where Webpack should look for modules.
                            modules: [
                                'node_modules',
                                path_1["default"].resolve(__dirname, '../../node_modules'),
                                path_1["default"].resolve(fs_extra_1["default"].realpathSync(process.cwd()), 'node_modules'),
                            ]
                        },
                        optimization: {
                            runtimeChunk: {
                                // https://github.com/webpack/webpack/issues/7875
                                name: function (_a) {
                                    var name = _a.name;
                                    return "runtime_" + name;
                                }
                            },
                            removeAvailableModules: false,
                            // Only minimize client bundle in production because server bundle is only used for static site generation
                            minimize: isProd,
                            splitChunks: {
                                // Since the chunk name includes all origin chunk names it’s recommended for production builds with long term caching to NOT include [name] in the filenames
                                automaticNameDelimiter: '_',
                                minSize: 0,
                                chunks: 'all',
                                cacheGroups: __assign(__assign({ "default": false, vendors: false }, siteConfig.cacheGroups), { appVendor: {
                                        chunks: 'all',
                                        name: 'app_vendor',
                                        test: /[\\/]node_modules[\\/]/,
                                        priority: 20,
                                        minChunks: 1,
                                        reuseExistingChunk: true
                                    }, appCommon: {
                                        chunks: 'all',
                                        test: /[\\/]src[\\/]((?!pages).*)/,
                                        name: 'app_common',
                                        priority: 19,
                                        minChunks: 2,
                                        reuseExistingChunk: true
                                    }, pages: {
                                        chunks: 'async',
                                        test: /[\\/]src[\\/]pages[\\/]((?!preset).*)/,
                                        priority: 18,
                                        minChunks: 1,
                                        enforce: true,
                                        // test: (mod: any) => {
                                        //   const isPages = /[\\/]src[\\/]pages[\\/]((?!preset).*)/.test(mod.context)
                                        //   return isPages
                                        // },
                                        // reuseExistingChunk: true,
                                        name: function (mod) {
                                            var resolvedPath = mod.context.match(/[\\/]src[\\/]pages[\\/](.*)$/);
                                            var commonName = 'pages_common';
                                            var splitRoutes = siteConfig.splitRoutes;
                                            var modPath = commonName;
                                            // resolvedPath[1] is not with ".ext", value is `pages/${resolvedPath[1]}`
                                            if (resolvedPath && lodash_1["default"].isArray(splitRoutes)) {
                                                splitRoutes.some(function (_a) {
                                                    var test = _a.test, name = _a.name;
                                                    if (!(test instanceof RegExp) || !name || !test.test(resolvedPath[1])) {
                                                        return false;
                                                    }
                                                    modPath = name; // `p_${resolvedPath[1].replace(/[\\/]/g, '_')}`
                                                    return true;
                                                });
                                            }
                                            return modPath;
                                        }
                                    } })
                            }
                        },
                        module: {
                            rules: __spreadArrays([
                                !mock && {
                                    test: /[\\/]mock\.[t|j]sx?$/,
                                    use: 'null-loader',
                                    exclude: /node_modules/
                                },
                                {
                                    test: /\.jsx?$/,
                                    exclude: excludeJS,
                                    use: [cacheLoader, babelLoader]
                                }
                            ], getFixLibLoaders({ dll: dll, publicPath: publicPath, babelLoader: babelLoader }), [
                                useTs && {
                                    test: /\.tsx?$/,
                                    exclude: excludeJS,
                                    use: [
                                        cacheLoader,
                                        { loader: 'thread-loader' },
                                        babelLoader,
                                        {
                                            loader: 'ts-loader',
                                            options: {
                                                happyPackMode: true,
                                                transpileOnly: true
                                            }
                                        },
                                    ]
                                },
                                {
                                    test: /\.css$/,
                                    use: (isProd ? [mini_css_extract_plugin_1["default"].loader] : [cacheLoader, 'style-loader']).concat([
                                        'css-loader',
                                    ]),
                                    exclude: scssUpdate ? undefined : /\.ovine[\\/]styles[\\/]themes/
                                },
                                !scssUpdate && {
                                    test: /\.ovine[\\/]styles[\\/]themes[\\/].*\.css$/,
                                    use: [
                                        {
                                            loader: 'file-loader',
                                            options: {
                                                publicPath: publicPath,
                                                limit: 1,
                                                name: staticDirName + "/" + libName + "/" + stylesDirName + "/themes/[name]_[contenthash:6].css"
                                            }
                                        },
                                        require.resolve('./loaders/extract_loader'),
                                        'css-loader',
                                    ]
                                },
                                {
                                    test: /\.svg$/,
                                    issuer: /\.[t|j]sx$/,
                                    use: ['@svgr/webpack']
                                },
                                {
                                    test: /\.svg$/,
                                    issuer: [/\.css$/, /\.[t|j]s$/],
                                    use: [
                                        {
                                            loader: 'url-loader',
                                            options: {
                                                publicPath: publicPath,
                                                limit: 2000,
                                                esModule: false,
                                                name: !isProd ? '[path][name].[ext]' : 'assets/svgs/[name]_[contenthash:6].[ext]'
                                            }
                                        },
                                    ]
                                },
                                {
                                    test: new RegExp("\\." + ("(gif,png,jpg,ttf,ico,woff,woff2,eot" + (!siteConfig.staticFileExts ? '' : "," + siteConfig.staticFileExts)).replace(/,/gi, '|') + ")$"),
                                    exclude: [/[\\/]qs[\\/]/],
                                    use: [
                                        {
                                            loader: 'url-loader',
                                            options: {
                                                publicPath: publicPath,
                                                limit: 2000,
                                                name: !isProd
                                                    ? '[path][name].[ext]'
                                                    : function (modulePath) {
                                                        var pathAr = modulePath
                                                            .split('/')
                                                            .filter(function (i) { return i !== 'assets'; })
                                                            .slice(-2);
                                                        return "assets/" + path_1["default"].dirname(pathAr.join('/')) + "/[name]_[contenthash:6].[ext]";
                                                    }
                                            }
                                        },
                                    ]
                                },
                            ]).filter(Boolean)
                        },
                        plugins: [
                            new log_plugin_1["default"]({
                                name: libName + "-" + (isProd ? 'Build' : 'Dev')
                            }),
                            new clean_webpack_plugin_1["default"](),
                            !dll &&
                                new monaco_editor_plugin_1["default"]({
                                    publicPath: publicPath
                                }),
                            getCopyPlugin(siteDir, outDir),
                            new webpack_1.EnvironmentPlugin({
                                PUBLIC_PATH: publicPath,
                                NODE_ENV: process.env.NODE_ENV,
                                INIT_THEME: ui.appTheme || ui.defaultTheme,
                                HOT: options.hot || false,
                                MOCK: mock,
                                ENV: env
                            }),
                            new webpack_1.ProvidePlugin({
                                $: 'jquery',
                                jQuery: 'jquery'
                            }),
                            useTs &&
                                new fork_ts_checker_webpack_plugin_1["default"]({
                                    tsconfig: siteDir + "/" + tsConfFileName,
                                    eslint: fs_extra_1["default"].existsSync(siteDir + "/" + esLintFileName),
                                    eslintOptions: fs_extra_1["default"].existsSync(siteDir + "/" + esLintFileName) &&
                                        require(siteDir + "/" + esLintFileName),
                                    tslint: !fs_extra_1["default"].existsSync(siteDir + "/" + tsLintConfFileName)
                                        ? undefined
                                        : siteDir + "/" + tsLintConfFileName,
                                    reportFiles: ['src/**/*.{ts,tsx}', 'typings/**/*.{ts,tsx}'],
                                    silent: true
                                }),
                            dll &&
                                new webpack_1.DllReferencePlugin({
                                    context: siteDir,
                                    manifest: manifestFile
                                }),
                            new mini_css_extract_plugin_1["default"]({
                                filename: isProd ? '[name]_[contenthash:6].css' : '[name].css',
                                chunkFilename: isProd ? 'chunks/[name]_[contenthash:6].css' : 'chunks/[name].css',
                                // remove css order warnings if css imports are not sorted alphabetically
                                // see https://github.com/webpack-contrib/mini-css-extract-plugin/pull/422 for more reasoning
                                ignoreOrder: true
                            }),
                            !scssUpdate &&
                                new assets_webpack_plugin_1["default"]({
                                    manifestFirst: true,
                                    keepInMemory: !isProd,
                                    includeAllFileTypes: false,
                                    fileTypes: ['css'],
                                    filename: cssAssetsFile.split('/')[1],
                                    fullPath: false,
                                    path: siteDir + "/" + cssAssetsFile.split('/')[0]
                                }),
                            !scssUpdate &&
                                new html_hooks_plugin_1["default"]({
                                    scssUpdate: scssUpdate,
                                    isProd: isProd,
                                    indexHtml: outDir + "/index.html",
                                    getThemeTpl: function (opts) {
                                        var themeOpts = __assign({ publicPath: publicPath,
                                            siteDir: siteDir, defaultTheme: ui.defaultTheme, appTheme: ui.appTheme }, opts);
                                        return getThemeTpl(themeOpts);
                                    }
                                }),
                            new html_webpack_plugin_1["default"](__assign(__assign({}, lodash_1["default"].pick(siteConfig.template, ['head', 'preBody', 'postBody'])), { isProd: isProd,
                                libVer: libVer,
                                publicPath: publicPath, title: siteConfig.title, favIcon: siteConfig.favicon, withIconfont: (_a = siteConfig.ui) === null || _a === void 0 ? void 0 : _a.withIconfont, withoutPace: (_b = siteConfig.ui) === null || _b === void 0 ? void 0 : _b.withoutPace, staticLibPath: "" + publicPath + staticLibDirPath + "/", template: ((_c = siteConfig.template) === null || _c === void 0 ? void 0 : _c.path) || path_1["default"].resolve(__dirname, './template.ejs'), filename: outDir + "/index.html", dllVendorCss: getDllDistFile(dllFilesHostDir, assetJson, dllVendorFileName, 'css'), dllVendorJs: dll &&
                                    dllFileKeys
                                        .map(function (fileKey) { return getDllDistFile(dllFilesHostDir, assetJson, fileKey, 'js'); })
                                        .join(',') })),
                        ].filter(Boolean)
                    };
                    config = utils_1.mergeWebpackConfig(baseConfig, siteDir + "/" + webpackConfFileName);
                    return [2 /*return*/, config];
            }
        });
    });
}
exports.createBaseConfig = createBaseConfig;
function excludeJS(modulePath) {
    // exclude fixed amis file
    var regs = ['editorFileReg', 'factoryFileReg', 'froalaEditorReg', 'chartFileReg', 'apiUtilReg'];
    if (Object.values(lodash_1.pick(amis, regs)).some(function (reg) { return reg.test(modulePath); })) {
        return true;
    }
    // Don't transpile node_modules except any @ovine npm package
    var isNodeModules = /node_modules/.test(modulePath);
    var isLibModules = /node_modules[\\/]@ovine[\\/].*\.[j|t]sx?$/.test(modulePath);
    // if (/editor\.min\.js$/.test(modulePath)) {
    //   console.log('@+++?', modulePath)
    //   return true
    // }
    return isLibModules ? false : isNodeModules;
}
function getAppEntries(option) {
    var siteDir = option.siteDir, hot = option.hot;
    var entries = hot ? ['react-hot-loader/patch'] : [];
    var siteSrcDir = siteDir + "/" + srcDirName + "/";
    var extArr = ['js', 'jsx', 'ts', 'tsx'];
    var getLibFile = function (fileName) {
        return utils_1.getModulePath(siteDir, "lib/core/lib/app/" + fileName, true);
    };
    var isAutoEntry = extArr
        .map(function (ext) { return "app.auto." + ext; })
        .map(function (file) { return fs_extra_1["default"].existsSync("" + siteSrcDir + file); })
        .filter(Boolean).length === 1;
    // use app.config for entry
    if (isAutoEntry) {
        entries.push(getLibFile('entry_auto.js'));
        return entries;
    }
    var isCustomEntry = extArr
        .map(function (ext) { return "app.custom." + ext; })
        .map(function (file) { return fs_extra_1["default"].existsSync("" + siteSrcDir + file); })
        .filter(Boolean).length === 1;
    // use app.custom for entry
    if (isCustomEntry) {
        entries.push(getLibFile('entry_custom.js'));
        return entries;
    }
    // use app for entry  -----> ovineCore would not anything. All give to developer!
    var appEntryExtIdx = extArr
        .map(function (ext) { return "app." + ext; })
        .map(function (file) { return fs_extra_1["default"].existsSync("" + siteSrcDir + file); })
        .findIndex(function (i) { return i; });
    if (appEntryExtIdx > -1) {
        entries.push(siteSrcDir + "app." + extArr[appEntryExtIdx]);
        return entries;
    }
    throw new Error('no app entry!! please add entry file.');
}
function getFixLibLoaders(option) {
    var dll = option.dll, babelLoader = option.babelLoader;
    var loaders = [
        {
            test: amis.editorFileReg,
            use: [babelLoader, amis.fixEditorLoader()]
        },
        {
            test: amis.factoryFileReg,
            use: [babelLoader, amis.fixFactoryLoader()]
        },
        {
            test: amis.froalaEditorReg,
            use: [babelLoader, amis.fixFroalaLoader()]
        },
        {
            test: amis.chartFileReg,
            use: [babelLoader, amis.fixChartLoader()]
        },
        {
            test: amis.apiUtilReg,
            use: [babelLoader, amis.fixApiUtilLoader()]
        },
    ];
    return dll ? [] : loaders;
}
function getDllDistFile(dllFilesHostDir, assetJson, fileKey, type) {
    if (fileKey === void 0) { fileKey = dllVendorFileName; }
    if (type === void 0) { type = 'js'; }
    return "" + dllFilesHostDir + lodash_1["default"].get(assetJson, fileKey + "." + type);
}
function getCopyPlugin(siteDir, outDir) {
    var generatedStaticDir = siteDir + "/" + generatedDirName + "/" + staticDirName;
    var generatedStylesDir = siteDir + "/" + generatedDirName + "/" + stylesDirName;
    var siteStaticDir = siteDir + "/" + staticDirName;
    var outStaticDir = outDir + "/" + staticDirName;
    var outLibDir = outDir + "/" + staticLibDirPath;
    var copyFiles = [
        {
            from: generatedStaticDir,
            to: outLibDir
        },
    ];
    if (fs_extra_1["default"].pathExistsSync(siteStaticDir)) {
        copyFiles.unshift({
            from: siteStaticDir,
            to: outStaticDir
        });
    }
    // copy static theme files
    if (fs_extra_1["default"].pathExistsSync(generatedStylesDir + "/themes/default.css")) {
        copyFiles.unshift({
            from: generatedStylesDir,
            to: outLibDir + "/" + stylesDirName
        });
    }
    var coreStatic = utils_1.getModulePath(siteDir, 'lib/core/static');
    if (coreStatic) {
        copyFiles.unshift({
            from: coreStatic,
            to: outLibDir + "/core"
        });
    }
    return new copy_webpack_plugin_1["default"](copyFiles);
}
function getThemeTpl(options) {
    var siteDir = options.siteDir, localFs = options.localFs, defaultTheme = options.defaultTheme, publicPath = options.publicPath, appTheme = options.appTheme;
    var cssAssetsJson = JSON.parse(localFs.readFileSync(siteDir + "/" + cssAssetsFile, 'utf8'));
    var cssAssets = lodash_1["default"].get(cssAssetsJson, '.css') || [];
    var tpl = {
        link: '',
        script: ''
    };
    if (!cssAssets || !cssAssets.map) {
        return tpl;
    }
    var themesArr = cssAssets.filter(function (i) { return /themes\/[a-z]*_\w{6}\.css/.test(i); });
    var themes = (themesArr.length
        ? themesArr
        : cssAssets.filter(function (i) { return /themes\/.*\.css$/.test(i); })).map(function (i) { return "" + publicPath + i; });
    if (!themes.length) {
        return tpl;
    }
    var checkTheme = function (t) { return t && themes.some(function (theme) { return theme.indexOf(t) > -1; }); };
    var presetTheme = checkTheme(defaultTheme) ? defaultTheme : 'default';
    if (appTheme === 'false') {
        return tpl;
    }
    if (checkTheme(appTheme)) {
        var link = themes.find(function (t) { return t.indexOf(appTheme) > -1; });
        tpl.link = "<link rel=\"stylesheet\" href=\"" + link + "\" />";
        tpl.script = "localStorage.setItem('libAppThemeStore', '\"" + appTheme + "\"');";
        return tpl;
    }
    tpl.script = "\n    (function() {\n      var themes = \"" + themes + "\".split(',');\n      var themeName = (localStorage.getItem('libAppThemeStore') || '').replace(/\"/g, '') || '" + presetTheme + "';\n      var linkHref = themes.find((t) => t.indexOf(themeName) > -1);\n      var head = document.head || document.getElementsByTagName('head')[0];\n      var link = document.createElement('link');\n      head.appendChild(link);\n      link.rel = 'stylesheet';\n      link.type = 'text/css';\n      link.dataset.theme = themeName;\n      link.href= linkHref;\n    })();\n  ";
    return tpl;
}
function loadDllManifest(options) {
    return __awaiter(this, void 0, void 0, function () {
        function getManifest(filesData) {
            try {
                var assetJson = require(filesData.assetsFile);
                return __assign({ assetJson: assetJson,
                    hostDir: hostDir }, filesData);
            }
            catch (err) {
                console.log(chalk_1["default"].red("\nload assetsFile: " + filesData.assetsFile + " with error. \n", err));
                throw err;
            }
        }
        var siteDir, _a, hostDir, backHostDir, files, assetsFile, manifestFile, backFiles, cacheDir, dllHostDirKey, assetsFileName, manifestFileName, cacheAssetsFile, cacheManifestFile, cachedFiles, fetchManifest, manifestInfo, err_1;
        var _this = this;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    siteDir = options.siteDir;
                    _a = utils_1.getDllHostDir(options.siteConfig), hostDir = _a[0], backHostDir = _a[1];
                    files = utils_1.getDllManifestFile(siteDir);
                    assetsFile = files.assetsFile, manifestFile = files.manifestFile;
                    backFiles = __assign(__assign({}, files), { hostDir: backHostDir });
                    cacheDir = siteDir + "/" + generatedDirName + "/cache";
                    dllHostDirKey = 'DLL_HOST_DIR';
                    assetsFileName = path_1["default"].basename(assetsFile);
                    manifestFileName = path_1["default"].basename(manifestFile);
                    cacheAssetsFile = cacheDir + "/" + assetsFileName;
                    cacheManifestFile = cacheDir + "/" + manifestFileName;
                    cachedFiles = {
                        hostDir: hostDir,
                        assetsFile: cacheAssetsFile,
                        manifestFile: cacheManifestFile
                    };
                    fetchManifest = function () { return __awaiter(_this, void 0, void 0, function () {
                        var assetJson, httpAssetFile, httpManifestFile;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!lodash_1["default"].values(cachedFiles).every(function (filePath) { return fs_extra_1["default"].existsSync(filePath); })) return [3 /*break*/, 2];
                                    return [4 /*yield*/, fs_extra_1["default"].readJSON(cacheAssetsFile)
                                        // check the cache if valid
                                    ];
                                case 1:
                                    assetJson = _a.sent();
                                    // check the cache if valid
                                    if (assetJson[winConst.dllVersion] === dllVer && assetJson[dllHostDirKey] === hostDir) {
                                        // already cached
                                        return [2 /*return*/, getManifest(cachedFiles)];
                                    }
                                    _a.label = 2;
                                case 2:
                                    httpAssetFile = "" + hostDir + assetsFileName;
                                    httpManifestFile = "" + hostDir + manifestFileName;
                                    // download manifest files to cache
                                    return [4 /*yield*/, Promise.all([httpAssetFile, httpManifestFile].map(function (httpFile) {
                                            return utils_1.fetchFile(httpFile).then(function (fileRes) {
                                                if (fileRes.headers['content-type'].indexOf('application/json') === -1) {
                                                    throw new Error("apply " + httpFile + " with error.");
                                                }
                                                var cachePath = cacheDir + "/" + path_1["default"].basename(httpFile);
                                                var jsonBody = fileRes.body;
                                                if (httpFile === httpAssetFile) {
                                                    var assetJson = JSON.parse(jsonBody);
                                                    assetJson[dllHostDirKey] = hostDir;
                                                    jsonBody = JSON.stringify(assetJson);
                                                }
                                                fs_extra_1["default"].ensureFileSync(cachePath);
                                                fs_extra_1["default"].writeFileSync(cachePath, jsonBody, {
                                                    encoding: 'utf-8'
                                                });
                                            });
                                        }))];
                                case 3:
                                    // download manifest files to cache
                                    _a.sent();
                                    return [2 /*return*/, getManifest(cachedFiles)];
                            }
                        });
                    }); };
                    manifestInfo = {};
                    if (!hostDir.startsWith('http')) return [3 /*break*/, 5];
                    _b.label = 1;
                case 1:
                    _b.trys.push([1, 3, , 4]);
                    return [4 /*yield*/, fetchManifest()];
                case 2:
                    manifestInfo = _b.sent();
                    return [3 /*break*/, 4];
                case 3:
                    err_1 = _b.sent();
                    manifestInfo = getManifest(backFiles);
                    return [3 /*break*/, 4];
                case 4: return [3 /*break*/, 6];
                case 5:
                    manifestInfo = getManifest(backFiles);
                    _b.label = 6;
                case 6: return [2 /*return*/, manifestInfo];
            }
        });
    });
}
exports.loadDllManifest = loadDllManifest;
